@@ -23,6 +23,10 @@
  ***************************************************************************/
 #include "tool_setup.h"
 
+#ifdef HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif
+
 #define ENABLE_CURLX_PRINTF
 /* use our own printf() functions */
 #include "curlx.h"
@@ -30,6 +34,7 @@
 #include "tool_cfgable.h"
 #include "tool_cb_rea.h"
 #include "tool_operate.h"
+#include "tool_util.h"
 
 #include "memdebug.h" /* keep this as LAST include */
 
@@ -39,8 +44,36 @@
 
 size_t tool_read_cb(char *buffer, size_t sz, size_t nmemb, void *userdata)
 {
-  ssize_t rc;
+  ssize_t rc = 0;
   struct InStruct *in = userdata;
+  struct OperationConfig *config = in->config;
+
+  if(config->timeout_ms) {
+    struct timeval now = tvnow();
+    long msdelta = tvdiff(now, in->per->start);
+
+    if(msdelta > config->timeout_ms)
+      /* timeout */
+      return 0;
+#ifndef WIN32
+    /* this logic waits on read activity on a file descriptor that is not a
+       socket which makes it not work with select() on Windows */
+    else {
+      fd_set bits;
+      struct timeval timeout;
+      long wait = config->timeout_ms - msdelta;
+
+      /* wait this long at the most */
+      timeout.tv_sec = wait/1000;
+      timeout.tv_usec = (wait%1000)*1000;
+
+      FD_ZERO(&bits);
+      FD_SET(in->fd, &bits);
+      if(!select(in->fd + 1, &bits, NULL, NULL, &timeout))
+        return 0; /* timeout */
+    }
+#endif
+  }
 
   rc = read(in->fd, buffer, sz*nmemb);
   if(rc < 0) {
@@ -53,6 +86,8 @@ size_t tool_read_cb(char *buffer, size_t sz, size_t nmemb, void *userdata)
     rc = 0;
   }
   in->config->readbusy = FALSE;
+
+  /* when select() rerturned zero here, it timed out */
   return (size_t)rc;
 }
 
