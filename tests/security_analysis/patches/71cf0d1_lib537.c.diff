@@ -50,7 +50,7 @@
 
 #if defined(HAVE_GETRLIMIT) && defined(HAVE_SETRLIMIT)
 
-static int *fd = NULL;
+static int *testfd = NULL;
 static struct rlimit num_open;
 static char msgbuff[256];
 
@@ -68,10 +68,10 @@ static void close_file_descriptors(void)
   for(num_open.rlim_cur = 0;
       num_open.rlim_cur < num_open.rlim_max;
       num_open.rlim_cur++)
-    if(fd[num_open.rlim_cur] > 0)
-      close(fd[num_open.rlim_cur]);
-  free(fd);
-  fd = NULL;
+    if(testfd[num_open.rlim_cur] > 0)
+      close(testfd[num_open.rlim_cur]);
+  free(testfd);
+  testfd = NULL;
 }
 
 static int fopen_works(void)
@@ -120,7 +120,7 @@ static void rlim2str(char *buf, size_t len, rlim_t val)
   }
 }
 
-static int rlimit(int keep_open)
+static int test_rlimit(int keep_open)
 {
   int *tmpfd;
   rlim_t nitems, i;
@@ -221,7 +221,7 @@ static int rlimit(int keep_open)
    * avoid a low memory condition once the file descriptors are
    * open. System conditions that could make the test fail should
    * be addressed in the precheck phase. This chunk of memory shall
-   * be always free()ed before exiting the rlimit() function so
+   * be always free()ed before exiting the test_rlimit() function so
    * that it becomes available to the test.
    */
 
@@ -273,7 +273,7 @@ static int rlimit(int keep_open)
 
   /* verify that we won't overflow size_t in malloc() */
 
-  if((size_t)(num_open.rlim_max) > ((size_t)-1) / sizeof(*fd)) {
+  if((size_t)(num_open.rlim_max) > ((size_t)-1) / sizeof(*testfd)) {
     rlim2str(strbuff1, sizeof(strbuff1), num_open.rlim_max);
     msnprintf(strbuff, sizeof(strbuff), "unable to allocate an array for %s "
               "file descriptors, would overflow size_t", strbuff1);
@@ -289,14 +289,14 @@ static int rlimit(int keep_open)
     rlim2str(strbuff, sizeof(strbuff), num_open.rlim_max);
     fprintf(stderr, "allocating array for %s file descriptors\n", strbuff);
 
-    fd = malloc(sizeof(*fd) * (size_t)(num_open.rlim_max));
-    if(!fd) {
-      fprintf(stderr, "fd, malloc() failed\n");
+    testfd = malloc(sizeof(*testfd) * (size_t)(num_open.rlim_max));
+    if(!testfd) {
+      fprintf(stderr, "testfd, malloc() failed\n");
       num_open.rlim_max /= 2;
     }
-  } while(num_open.rlim_max && !fd);
-  if(!fd) {
-    store_errmsg("fd, malloc() failed", errno);
+  } while(num_open.rlim_max && !testfd);
+  if(!testfd) {
+    store_errmsg("testfd, malloc() failed", errno);
     fprintf(stderr, "%s\n", msgbuff);
     free(memchunk);
     return -6;
@@ -304,25 +304,25 @@ static int rlimit(int keep_open)
 
   /* initialize it to fight lazy allocation */
 
-  fprintf(stderr, "initializing fd array\n");
+  fprintf(stderr, "initializing testfd array\n");
 
   for(num_open.rlim_cur = 0;
       num_open.rlim_cur < num_open.rlim_max;
       num_open.rlim_cur++)
-    fd[num_open.rlim_cur] = -1;
+    testfd[num_open.rlim_cur] = -1;
 
   rlim2str(strbuff, sizeof(strbuff), num_open.rlim_max);
   fprintf(stderr, "trying to open %s file descriptors\n", strbuff);
 
   /* open a dummy descriptor */
 
-  fd[0] = open(DEV_NULL, O_RDONLY);
-  if(fd[0] < 0) {
+  testfd[0] = open(DEV_NULL, O_RDONLY);
+  if(testfd[0] < 0) {
     msnprintf(strbuff, sizeof(strbuff), "opening of %s failed", DEV_NULL);
     store_errmsg(strbuff, errno);
     fprintf(stderr, "%s\n", msgbuff);
-    free(fd);
-    fd = NULL;
+    free(testfd);
+    testfd = NULL;
     free(memchunk);
     return -7;
   }
@@ -333,11 +333,11 @@ static int rlimit(int keep_open)
       num_open.rlim_cur < num_open.rlim_max;
       num_open.rlim_cur++) {
 
-    fd[num_open.rlim_cur] = dup(fd[0]);
+    testfd[num_open.rlim_cur] = dup(testfd[0]);
 
-    if(fd[num_open.rlim_cur] < 0) {
+    if(testfd[num_open.rlim_cur] < 0) {
 
-      fd[num_open.rlim_cur] = -1;
+      testfd[num_open.rlim_cur] = -1;
 
       rlim2str(strbuff1, sizeof(strbuff1), num_open.rlim_cur);
       msnprintf(strbuff, sizeof(strbuff), "dup() attempt %s failed", strbuff1);
@@ -357,10 +357,10 @@ static int rlimit(int keep_open)
       fprintf(stderr, "%s\n", strbuff);
 
       for(num_open.rlim_cur = num_open.rlim_max;
-          fd[num_open.rlim_cur] >= 0;
+          testfd[num_open.rlim_cur] >= 0;
           num_open.rlim_cur++) {
-        close(fd[num_open.rlim_cur]);
-        fd[num_open.rlim_cur] = -1;
+        close(testfd[num_open.rlim_cur]);
+        testfd[num_open.rlim_cur] = -1;
       }
 
       rlim2str(strbuff, sizeof(strbuff), num_open.rlim_max);
@@ -368,9 +368,9 @@ static int rlimit(int keep_open)
 
       /* we don't care if we can't shrink it */
 
-      tmpfd = realloc(fd, sizeof(*fd) * (size_t)(num_open.rlim_max));
+      tmpfd = realloc(testfd, sizeof(*testfd) * (size_t)(num_open.rlim_max));
       if(tmpfd) {
-        fd = tmpfd;
+        testfd = tmpfd;
         tmpfd = NULL;
       }
 
@@ -409,8 +409,8 @@ static int rlimit(int keep_open)
   for(rl.rlim_cur = 0;
       rl.rlim_cur < num_open.rlim_max;
       rl.rlim_cur++) {
-    if((fd[rl.rlim_cur] > 0) &&
-       ((unsigned int)fd[rl.rlim_cur] > num_open.rlim_cur)) {
+    if((testfd[rl.rlim_cur] > 0) &&
+       ((unsigned int)testfd[rl.rlim_cur] > num_open.rlim_cur)) {
       msnprintf(strbuff, sizeof(strbuff), "select limit is FD_SETSIZE %d",
                 FD_SETSIZE);
       store_errmsg(strbuff, 0);
@@ -465,14 +465,14 @@ CURLcode test(char *URL)
 
   if(!strcmp(URL, "check")) {
     /* used by the test script to ask if we can run this test or not */
-    if(rlimit(FALSE)) {
-      fprintf(stdout, "rlimit problem: %s\n", msgbuff);
+    if(test_rlimit(FALSE)) {
+      fprintf(stdout, "test_rlimit problem: %s\n", msgbuff);
       return (CURLcode)1;
     }
     return CURLE_OK; /* sure, run this! */
   }
 
-  if(rlimit(TRUE)) {
+  if(test_rlimit(TRUE)) {
     /* failure */
     return TEST_ERR_MAJOR_BAD;
   }
