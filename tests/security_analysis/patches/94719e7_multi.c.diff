@@ -83,19 +83,19 @@ static void process_pending_handles(struct Curl_multi *multi);
 #ifdef DEBUGBUILD
 static const char * const statename[]={
   "INIT",
-  "CONNECT_PEND",
+  "PENDING",
   "CONNECT",
-  "WAITRESOLVE",
-  "WAITCONNECT",
-  "WAITPROXYCONNECT",
-  "SENDPROTOCONNECT",
+  "RESOLVING",
+  "CONNECTING",
+  "TUNNELING",
   "PROTOCONNECT",
+  "PROTOCONNECTING",
   "DO",
   "DOING",
-  "DO_MORE",
-  "DO_DONE",
-  "PERFORM",
-  "TOOFAST",
+  "DOING_MORE",
+  "DID",
+  "PERFORMING",
+  "RATELIMITING",
   "DONE",
   "COMPLETED",
   "MSGSENT",
@@ -130,21 +130,21 @@ static void mstate(struct Curl_easy *data, CURLMstate state
 )
 {
   CURLMstate oldstate = data->mstate;
-  static const init_multistate_func finit[CURLM_STATE_LAST] = {
+  static const init_multistate_func finit[MSTATE_LAST] = {
     NULL,              /* INIT */
-    NULL,              /* CONNECT_PEND */
+    NULL,              /* PENDING */
     Curl_init_CONNECT, /* CONNECT */
-    NULL,              /* WAITRESOLVE */
-    NULL,              /* WAITCONNECT */
-    NULL,              /* WAITPROXYCONNECT */
-    NULL,              /* SENDPROTOCONNECT */
+    NULL,              /* RESOLVING */
+    NULL,              /* CONNECTING */
+    NULL,              /* TUNNELING */
     NULL,              /* PROTOCONNECT */
+    NULL,              /* PROTOCONNECTING */
     Curl_connect_free, /* DO */
     NULL,              /* DOING */
-    NULL,              /* DO_MORE */
-    NULL,              /* DO_DONE */
-    init_perform,      /* PERFORM */
-    NULL,              /* TOOFAST */
+    NULL,              /* DOING_MORE */
+    NULL,              /* DID */
+    init_perform,      /* PERFORMING */
+    NULL,              /* RATELIMITING */
     NULL,              /* DONE */
     init_completed,    /* COMPLETED */
     NULL               /* MSGSENT */
@@ -161,8 +161,8 @@ static void mstate(struct Curl_easy *data, CURLMstate state
   data->mstate = state;
 
 #if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)
-  if(data->mstate >= CURLM_STATE_CONNECT_PEND &&
-     data->mstate < CURLM_STATE_COMPLETED) {
+  if(data->mstate >= MSTATE_PENDING &&
+     data->mstate < MSTATE_COMPLETED) {
     long connection_id = -5000;
 
     if(data->conn)
@@ -175,7 +175,7 @@ static void mstate(struct Curl_easy *data, CURLMstate state
   }
 #endif
 
-  if(state == CURLM_STATE_COMPLETED) {
+  if(state == MSTATE_COMPLETED) {
     /* changing to COMPLETED means there's one less easy handle 'alive' */
     DEBUGASSERT(data->multi->num_alive > 0);
     data->multi->num_alive--;
@@ -447,7 +447,7 @@ CURLMcode curl_multi_add_handle(struct Curl_multi *multi,
     data->set.errorbuffer[0] = 0;
 
   /* set the easy handle */
-  multistate(data, CURLM_STATE_INIT);
+  multistate(data, MSTATE_INIT);
 
   /* for multi interface connections, we share DNS cache automatically if the
      easy handle's one is currently not set. */
@@ -734,7 +734,7 @@ CURLMcode curl_multi_remove_handle(struct Curl_multi *multi,
   if(multi->in_callback)
     return CURLM_RECURSIVE_API_CALL;
 
-  premature = (data->mstate < CURLM_STATE_COMPLETED) ? TRUE : FALSE;
+  premature = (data->mstate < MSTATE_COMPLETED) ? TRUE : FALSE;
 
   /* If the 'state' is not INIT or COMPLETED, we might need to do something
      nice to put the easy_handle in a good known state when this returns. */
@@ -745,8 +745,8 @@ CURLMcode curl_multi_remove_handle(struct Curl_multi *multi,
   }
 
   if(data->conn &&
-     data->mstate > CURLM_STATE_DO &&
-     data->mstate < CURLM_STATE_COMPLETED) {
+     data->mstate > MSTATE_DO &&
+     data->mstate < MSTATE_COMPLETED) {
     /* Set connection owner so that the DONE function closes it.  We can
        safely do this here since connection is killed. */
     streamclose(data->conn, "Removed with partial response");
@@ -786,7 +786,7 @@ CURLMcode curl_multi_remove_handle(struct Curl_multi *multi,
 
   /* change state without using multistate(), only to make singlesocket() do
      what we want */
-  data->mstate = CURLM_STATE_COMPLETED;
+  data->mstate = MSTATE_COMPLETED;
   singlesocket(multi, easy); /* to let the application know what sockets that
                                 vanish with this handle */
 
@@ -972,30 +972,29 @@ static int multi_getsock(struct Curl_easy *data,
   default:
     return 0;
 
-  case CURLM_STATE_WAITRESOLVE:
+  case MSTATE_RESOLVING:
     return Curl_resolv_getsock(data, socks);
 
-  case CURLM_STATE_PROTOCONNECT:
-  case CURLM_STATE_SENDPROTOCONNECT:
+  case MSTATE_PROTOCONNECTING:
+  case MSTATE_PROTOCONNECT:
     return protocol_getsock(data, conn, socks);
 
-  case CURLM_STATE_DO:
-  case CURLM_STATE_DOING:
+  case MSTATE_DO:
+  case MSTATE_DOING:
     return doing_getsock(data, conn, socks);
 
-  case CURLM_STATE_WAITPROXYCONNECT:
+  case MSTATE_TUNNELING:
     return waitproxyconnect_getsock(conn, socks);
 
-  case CURLM_STATE_WAITCONNECT:
+  case MSTATE_CONNECTING:
     return waitconnect_getsock(conn, socks);
 
-  case CURLM_STATE_DO_MORE:
+  case MSTATE_DOING_MORE:
     return domore_getsock(data, conn, socks);
 
-  case CURLM_STATE_DO_DONE: /* since is set after DO is completed, we switch
-                               to waiting for the same as the *PERFORM
-                               states */
-  case CURLM_STATE_PERFORM:
+  case MSTATE_DID: /* since is set after DO is completed, we switch to
+                        waiting for the same as the PERFORMING state */
+  case MSTATE_PERFORMING:
     return Curl_single_getsock(data, conn, socks);
   }
 
@@ -1361,7 +1360,7 @@ CURLMcode Curl_multi_add_perform(struct Curl_multi *multi,
     Curl_init_do(data, NULL);
 
     /* take this handle to the perform state right away */
-    multistate(data, CURLM_STATE_PERFORM);
+    multistate(data, MSTATE_PERFORMING);
     Curl_attach_connnection(data, conn);
     k->keepon |= KEEP_RECV; /* setup to receive! */
   }
@@ -1555,8 +1554,8 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       process_pending_handles(multi); /* multiplexed */
     }
 
-    if(data->mstate > CURLM_STATE_CONNECT &&
-       data->mstate < CURLM_STATE_COMPLETED) {
+    if(data->mstate > MSTATE_CONNECT &&
+       data->mstate < MSTATE_COMPLETED) {
       /* Make sure we set the connection's current owner */
       DEBUGASSERT(data->conn);
       if(!data->conn)
@@ -1564,21 +1563,21 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
     }
 
     if(data->conn &&
-       (data->mstate >= CURLM_STATE_CONNECT) &&
-       (data->mstate < CURLM_STATE_COMPLETED)) {
+       (data->mstate >= MSTATE_CONNECT) &&
+       (data->mstate < MSTATE_COMPLETED)) {
       /* we need to wait for the connect state as only then is the start time
          stored, but we must not check already completed handles */
       timeout_ms = Curl_timeleft(data, nowp,
-                                 (data->mstate <= CURLM_STATE_DO)?
+                                 (data->mstate <= MSTATE_DO)?
                                  TRUE:FALSE);
 
       if(timeout_ms < 0) {
         /* Handle timed out */
-        if(data->mstate == CURLM_STATE_WAITRESOLVE)
+        if(data->mstate == MSTATE_RESOLVING)
           failf(data, "Resolving timed out after %" CURL_FORMAT_TIMEDIFF_T
                 " milliseconds",
                 Curl_timediff(*nowp, data->progress.t_startsingle));
-        else if(data->mstate == CURLM_STATE_WAITCONNECT)
+        else if(data->mstate == MSTATE_CONNECTING)
           failf(data, "Connection timed out after %" CURL_FORMAT_TIMEDIFF_T
                 " milliseconds",
                 Curl_timediff(*nowp, data->progress.t_startsingle));
@@ -1601,7 +1600,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
         }
 
         /* Force connection closed if the connection has indeed been used */
-        if(data->mstate > CURLM_STATE_DO) {
+        if(data->mstate > MSTATE_DO) {
           streamclose(data->conn, "Disconnected with pending data");
           stream_error = TRUE;
         }
@@ -1613,24 +1612,24 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
     }
 
     switch(data->mstate) {
-    case CURLM_STATE_INIT:
+    case MSTATE_INIT:
       /* init this transfer. */
       result = Curl_pretransfer(data);
 
       if(!result) {
         /* after init, go CONNECT */
-        multistate(data, CURLM_STATE_CONNECT);
+        multistate(data, MSTATE_CONNECT);
         *nowp = Curl_pgrsTime(data, TIMER_STARTOP);
         rc = CURLM_CALL_MULTI_PERFORM;
       }
       break;
 
-    case CURLM_STATE_CONNECT_PEND:
+    case MSTATE_PENDING:
       /* We will stay here until there is a connection available. Then
-         we try again in the CURLM_STATE_CONNECT state. */
+         we try again in the MSTATE_CONNECT state. */
       break;
 
-    case CURLM_STATE_CONNECT:
+    case MSTATE_CONNECT:
       /* Connect. We want to get a connection identifier filled in. */
       /* init this transfer. */
       result = Curl_preconnect(data);
@@ -1648,7 +1647,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       if(CURLE_NO_CONNECTION_AVAILABLE == result) {
         /* There was no connection available. We will go to the pending
            state and wait for an available connection. */
-        multistate(data, CURLM_STATE_CONNECT_PEND);
+        multistate(data, MSTATE_PENDING);
 
         /* add this handle to the list of connect-pending handles */
         Curl_llist_insert_next(&multi->pending, multi->pending.tail, data,
@@ -1665,7 +1664,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       if(!result) {
         if(async)
           /* We're now waiting for an asynchronous name lookup */
-          multistate(data, CURLM_STATE_WAITRESOLVE);
+          multistate(data, MSTATE_RESOLVING);
         else {
           /* after the connect has been sent off, go WAITCONNECT unless the
              protocol connect is already done and we can go directly to
@@ -1673,20 +1672,20 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
           rc = CURLM_CALL_MULTI_PERFORM;
 
           if(protocol_connected)
-            multistate(data, CURLM_STATE_DO);
+            multistate(data, MSTATE_DO);
           else {
 #ifndef CURL_DISABLE_HTTP
             if(Curl_connect_ongoing(data->conn))
-              multistate(data, CURLM_STATE_WAITPROXYCONNECT);
+              multistate(data, MSTATE_TUNNELING);
             else
 #endif
-              multistate(data, CURLM_STATE_WAITCONNECT);
+              multistate(data, MSTATE_CONNECTING);
           }
         }
       }
       break;
 
-    case CURLM_STATE_WAITRESOLVE:
+    case MSTATE_RESOLVING:
       /* awaiting an asynch name resolve to complete */
     {
       struct Curl_dns_entry *dns = NULL;
@@ -1740,14 +1739,14 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
           /* call again please so that we get the next socket setup */
           rc = CURLM_CALL_MULTI_PERFORM;
           if(protocol_connected)
-            multistate(data, CURLM_STATE_DO);
+            multistate(data, MSTATE_DO);
           else {
 #ifndef CURL_DISABLE_HTTP
             if(Curl_connect_ongoing(data->conn))
-              multistate(data, CURLM_STATE_WAITPROXYCONNECT);
+              multistate(data, MSTATE_TUNNELING);
             else
 #endif
-              multistate(data, CURLM_STATE_WAITCONNECT);
+              multistate(data, MSTATE_CONNECTING);
           }
         }
       }
@@ -1761,7 +1760,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
     break;
 
 #ifndef CURL_DISABLE_HTTP
-    case CURLM_STATE_WAITPROXYCONNECT:
+    case MSTATE_TUNNELING:
       /* this is HTTP-specific, but sending CONNECT to a proxy is HTTP... */
       DEBUGASSERT(data->conn);
       result = Curl_http_connect(data, &protocol_connected);
@@ -1771,7 +1770,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
         /* connect back to proxy again */
         result = CURLE_OK;
         multi_done(data, CURLE_OK, FALSE);
-        multistate(data, CURLM_STATE_CONNECT);
+        multistate(data, MSTATE_CONNECT);
       }
       else
 #endif
@@ -1784,7 +1783,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
             Curl_connect_complete(data->conn)) {
             rc = CURLM_CALL_MULTI_PERFORM;
             /* initiate protocol connect phase */
-            multistate(data, CURLM_STATE_SENDPROTOCONNECT);
+            multistate(data, MSTATE_PROTOCONNECT);
           }
         }
       else
@@ -1792,7 +1791,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       break;
 #endif
 
-    case CURLM_STATE_WAITCONNECT:
+    case MSTATE_CONNECTING:
       /* awaiting a completion of an asynch TCP connect */
       DEBUGASSERT(data->conn);
       result = Curl_is_connected(data, data->conn, FIRSTSOCKET, &connected);
@@ -1804,7 +1803,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
            !data->conn->bits.proxy_ssl_connected[FIRSTSOCKET]) ||
 #endif
           Curl_connect_ongoing(data->conn)) {
-          multistate(data, CURLM_STATE_WAITPROXYCONNECT);
+          multistate(data, MSTATE_TUNNELING);
           break;
         }
 #endif
@@ -1812,10 +1811,9 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
 #ifndef CURL_DISABLE_PROXY
         multistate(data,
                    data->conn->bits.tunnel_proxy?
-                   CURLM_STATE_WAITPROXYCONNECT:
-                   CURLM_STATE_SENDPROTOCONNECT);
+                   MSTATE_TUNNELING : MSTATE_PROTOCONNECT);
 #else
-        multistate(data, CURLM_STATE_SENDPROTOCONNECT);
+        multistate(data, MSTATE_PROTOCONNECT);
 #endif
       }
       else if(result) {
@@ -1827,14 +1825,14 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       }
       break;
 
-    case CURLM_STATE_SENDPROTOCONNECT:
+    case MSTATE_PROTOCONNECT:
       result = protocol_connect(data, &protocol_connected);
       if(!result && !protocol_connected)
         /* switch to waiting state */
-        multistate(data, CURLM_STATE_PROTOCONNECT);
+        multistate(data, MSTATE_PROTOCONNECTING);
       else if(!result) {
         /* protocol connect has completed, go WAITDO or DO */
-        multistate(data, CURLM_STATE_DO);
+        multistate(data, MSTATE_DO);
         rc = CURLM_CALL_MULTI_PERFORM;
       }
       else {
@@ -1845,12 +1843,12 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       }
       break;
 
-    case CURLM_STATE_PROTOCONNECT:
+    case MSTATE_PROTOCONNECTING:
       /* protocol-specific connect phase */
       result = protocol_connecting(data, &protocol_connected);
       if(!result && protocol_connected) {
         /* after the connect has completed, go WAITDO or DO */
-        multistate(data, CURLM_STATE_DO);
+        multistate(data, MSTATE_DO);
         rc = CURLM_CALL_MULTI_PERFORM;
       }
       else if(result) {
@@ -1861,11 +1859,11 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       }
       break;
 
-    case CURLM_STATE_DO:
+    case MSTATE_DO:
       if(data->set.connect_only) {
         /* keep connection open for application to use the socket */
         connkeep(data->conn, "CONNECT_ONLY");
-        multistate(data, CURLM_STATE_DONE);
+        multistate(data, MSTATE_DONE);
         result = CURLE_OK;
         rc = CURLM_CALL_MULTI_PERFORM;
       }
@@ -1887,7 +1885,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
 
                 /* if there's no connection left, skip the DONE state */
                 multistate(data, data->conn ?
-                           CURLM_STATE_DONE : CURLM_STATE_COMPLETED);
+                           MSTATE_DONE : MSTATE_COMPLETED);
                 rc = CURLM_CALL_MULTI_PERFORM;
                 break;
               }
@@ -1895,7 +1893,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
 #endif
             /* DO was not completed in one function call, we must continue
                DOING... */
-            multistate(data, CURLM_STATE_DOING);
+            multistate(data, MSTATE_DOING);
             rc = CURLM_OK;
           }
 
@@ -1903,12 +1901,12 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
           else if(data->conn->bits.do_more) {
             /* we're supposed to do more, but we need to sit down, relax
                and wait a little while first */
-            multistate(data, CURLM_STATE_DO_MORE);
+            multistate(data, MSTATE_DOING_MORE);
             rc = CURLM_OK;
           }
           else {
-            /* we're done with the DO, now DO_DONE */
-            multistate(data, CURLM_STATE_DO_DONE);
+            /* we're done with the DO, now DID */
+            multistate(data, MSTATE_DID);
             rc = CURLM_CALL_MULTI_PERFORM;
           }
         }
@@ -1940,7 +1938,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
               follow = FOLLOW_RETRY;
               drc = Curl_follow(data, newurl, follow);
               if(!drc) {
-                multistate(data, CURLM_STATE_CONNECT);
+                multistate(data, MSTATE_CONNECT);
                 rc = CURLM_CALL_MULTI_PERFORM;
                 result = CURLE_OK;
               }
@@ -1970,7 +1968,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       }
       break;
 
-    case CURLM_STATE_DOING:
+    case MSTATE_DOING:
       /* we continue DOING until the DO phase is complete */
       DEBUGASSERT(data->conn);
       result = protocol_doing(data, &dophase_done);
@@ -1978,8 +1976,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
         if(dophase_done) {
           /* after DO, go DO_DONE or DO_MORE */
           multistate(data, data->conn->bits.do_more?
-                     CURLM_STATE_DO_MORE:
-                     CURLM_STATE_DO_DONE);
+                     MSTATE_DOING_MORE : MSTATE_DID);
           rc = CURLM_CALL_MULTI_PERFORM;
         } /* dophase_done */
       }
@@ -1991,9 +1988,9 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       }
       break;
 
-    case CURLM_STATE_DO_MORE:
+    case MSTATE_DOING_MORE:
       /*
-       * When we are connected, DO MORE and then go DO_DONE
+       * When we are connected, DOING MORE and then go DID
        */
       DEBUGASSERT(data->conn);
       result = multi_do_more(data, &control);
@@ -2003,8 +2000,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
           /* if positive, advance to DO_DONE
              if negative, go back to DOING */
           multistate(data, control == 1?
-                     CURLM_STATE_DO_DONE:
-                     CURLM_STATE_DOING);
+                     MSTATE_DID : MSTATE_DOING);
           rc = CURLM_CALL_MULTI_PERFORM;
         }
         else
@@ -2019,7 +2015,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       }
       break;
 
-    case CURLM_STATE_DO_DONE:
+    case MSTATE_DID:
       DEBUGASSERT(data->conn);
       if(data->conn->bits.multiplex)
         /* Check if we can move pending requests to send pipe */
@@ -2029,7 +2025,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
          Having both BAD is a signal to skip immediately to DONE */
       if((data->conn->sockfd != CURL_SOCKET_BAD) ||
          (data->conn->writesockfd != CURL_SOCKET_BAD))
-        multistate(data, CURLM_STATE_PERFORM);
+        multistate(data, MSTATE_PERFORMING);
       else {
 #ifndef CURL_DISABLE_FTP
         if(data->state.wildcardmatch &&
@@ -2037,12 +2033,12 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
           data->wildcard.state = CURLWC_DONE;
         }
 #endif
-        multistate(data, CURLM_STATE_DONE);
+        multistate(data, MSTATE_DONE);
       }
       rc = CURLM_CALL_MULTI_PERFORM;
       break;
 
-    case CURLM_STATE_TOOFAST: /* limit-rate exceeded in either direction */
+    case MSTATE_RATELIMITING: /* limit-rate exceeded in either direction */
       DEBUGASSERT(data->conn);
       /* if both rates are within spec, resume transfer */
       if(Curl_pgrsUpdate(data))
@@ -2078,7 +2074,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
                                    *nowp);
 
         if(!send_timeout_ms && !recv_timeout_ms) {
-          multistate(data, CURLM_STATE_PERFORM);
+          multistate(data, MSTATE_PERFORMING);
           Curl_ratelimit(data, *nowp);
         }
         else if(send_timeout_ms >= recv_timeout_ms)
@@ -2088,7 +2084,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       }
       break;
 
-    case CURLM_STATE_PERFORM:
+    case MSTATE_PERFORMING:
     {
       char *newurl = NULL;
       bool retry = FALSE;
@@ -2114,7 +2110,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
 
       if(send_timeout_ms || recv_timeout_ms) {
         Curl_ratelimit(data, *nowp);
-        multistate(data, CURLM_STATE_TOOFAST);
+        multistate(data, MSTATE_RATELIMITING);
         if(send_timeout_ms >= recv_timeout_ms)
           Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);
         else
@@ -2204,7 +2200,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
           /* multi_done() might return CURLE_GOT_NOTHING */
           result = Curl_follow(data, newurl, follow);
           if(!result) {
-            multistate(data, CURLM_STATE_CONNECT);
+            multistate(data, MSTATE_CONNECT);
             rc = CURLM_CALL_MULTI_PERFORM;
           }
           free(newurl);
@@ -2227,7 +2223,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
           }
 
           if(!result) {
-            multistate(data, CURLM_STATE_DONE);
+            multistate(data, MSTATE_DONE);
             rc = CURLM_CALL_MULTI_PERFORM;
           }
         }
@@ -2242,7 +2238,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       break;
     }
 
-    case CURLM_STATE_DONE:
+    case MSTATE_DONE:
       /* this state is highly transient, so run another loop after this */
       rc = CURLM_CALL_MULTI_PERFORM;
 
@@ -2265,21 +2261,21 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
       if(data->state.wildcardmatch) {
         if(data->wildcard.state != CURLWC_DONE) {
           /* if a wildcard is set and we are not ending -> lets start again
-             with CURLM_STATE_INIT */
-          multistate(data, CURLM_STATE_INIT);
+             with MSTATE_INIT */
+          multistate(data, MSTATE_INIT);
           break;
         }
       }
 #endif
       /* after we have DONE what we're supposed to do, go COMPLETED, and
          it doesn't matter what the multi_done() returned! */
-      multistate(data, CURLM_STATE_COMPLETED);
+      multistate(data, MSTATE_COMPLETED);
       break;
 
-    case CURLM_STATE_COMPLETED:
+    case MSTATE_COMPLETED:
       break;
 
-    case CURLM_STATE_MSGSENT:
+    case MSTATE_MSGSENT:
       data->result = result;
       return CURLM_OK; /* do nothing */
 
@@ -2288,7 +2284,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
     }
     statemachine_end:
 
-    if(data->mstate < CURLM_STATE_COMPLETED) {
+    if(data->mstate < MSTATE_COMPLETED) {
       if(result) {
         /*
          * If an error was returned, and we aren't in completed state now,
@@ -2319,12 +2315,12 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
             Curl_disconnect(data, conn, dead_connection);
           }
         }
-        else if(data->mstate == CURLM_STATE_CONNECT) {
+        else if(data->mstate == MSTATE_CONNECT) {
           /* Curl_connect() failed */
           (void)Curl_posttransfer(data);
         }
 
-        multistate(data, CURLM_STATE_COMPLETED);
+        multistate(data, MSTATE_COMPLETED);
         rc = CURLM_CALL_MULTI_PERFORM;
       }
       /* if there's still a connection to use, call the progress function */
@@ -2335,13 +2331,13 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
         streamclose(data->conn, "Aborted by callback");
 
         /* if not yet in DONE state, go there, otherwise COMPLETED */
-        multistate(data, (data->mstate < CURLM_STATE_DONE)?
-                   CURLM_STATE_DONE: CURLM_STATE_COMPLETED);
+        multistate(data, (data->mstate < MSTATE_DONE)?
+                   MSTATE_DONE: MSTATE_COMPLETED);
         rc = CURLM_CALL_MULTI_PERFORM;
       }
     }
 
-    if(CURLM_STATE_COMPLETED == data->mstate) {
+    if(MSTATE_COMPLETED == data->mstate) {
       if(data->set.fmultidone) {
         /* signal via callback instead */
         data->set.fmultidone(data, result);
@@ -2357,7 +2353,7 @@ static CURLMcode multi_runsingle(struct Curl_multi *multi,
         rc = multi_addmsg(multi, msg);
         DEBUGASSERT(!data->conn);
       }
-      multistate(data, CURLM_STATE_MSGSENT);
+      multistate(data, MSTATE_MSGSENT);
     }
   } while((rc == CURLM_CALL_MULTI_PERFORM) || multi_ischanged(multi, FALSE));
 
@@ -3320,9 +3316,9 @@ static void process_pending_handles(struct Curl_multi *multi)
   if(e) {
     struct Curl_easy *data = e->ptr;
 
-    DEBUGASSERT(data->mstate == CURLM_STATE_CONNECT_PEND);
+    DEBUGASSERT(data->mstate == MSTATE_PENDING);
 
-    multistate(data, CURLM_STATE_CONNECT);
+    multistate(data, MSTATE_CONNECT);
 
     /* Remove this node from the list */
     Curl_llist_remove(&multi->pending, e, NULL);
@@ -3360,7 +3356,7 @@ void Curl_multi_dump(struct Curl_multi *multi)
   fprintf(stderr, "* Multi status: %d handles, %d alive\n",
           multi->num_easy, multi->num_alive);
   for(data = multi->easyp; data; data = data->next) {
-    if(data->mstate < CURLM_STATE_COMPLETED) {
+    if(data->mstate < MSTATE_COMPLETED) {
       /* only display handles that are not completed */
       fprintf(stderr, "handle %p, state %s, %d sockets\n",
               (void *)data,
