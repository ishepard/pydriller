@@ -99,9 +99,7 @@ thdbufdestroy(void * private)
     localkey_t i;
 
     for(i = (localkey_t) 0; i < LK_LAST; i++) {
-      if(p->buf)
-        free(p->buf);
-
+      free(p->buf);
       p++;
       }
 
@@ -281,9 +279,7 @@ Curl_getnameinfo_a(const struct sockaddr * sa, curl_socklen_t salen,
 
   if(servname && servnamelen)
     if(!(eservname = malloc(servnamelen))) {
-      if(enodename)
-        free(enodename);
-
+      free(enodename);
       return EAI_MEMORY;
       }
 
@@ -304,12 +300,8 @@ Curl_getnameinfo_a(const struct sockaddr * sa, curl_socklen_t salen,
       }
     }
 
-  if(enodename)
-    free(enodename);
-
-  if(eservname)
-    free(eservname);
-
+  free(enodename);
+  free(eservname);
   return status;
 }
 
@@ -342,9 +334,7 @@ Curl_getaddrinfo_a(const char * nodename, const char * servname,
     i = strlen(servname);
 
     if(!(eservname = malloc(i + 1))) {
-      if(enodename)
-        free(enodename);
-
+      free(enodename);
       return EAI_MEMORY;
       }
 
@@ -353,13 +343,8 @@ Curl_getaddrinfo_a(const char * nodename, const char * servname,
     }
 
   status = getaddrinfo(enodename, eservname, hints, res);
-
-  if(enodename)
-    free(enodename);
-
-  if(eservname)
-    free(eservname);
-
+  free(enodename);
+  free(eservname);
   return status;
 }
 
@@ -886,9 +871,7 @@ Curl_gss_init_sec_context_a(OM_uint32 * minor_status,
                              target_name, mech_type, req_flags, time_req,
                              input_chan_bindings, inp, actual_mech_type,
                              output_token, ret_flags, time_rec);
-
-  if(in.value)
-    free(in.value);
+  free(in.value);
 
   if(rc != GSS_S_COMPLETE || !output_token ||
       !output_token->length || !output_token->value)
@@ -985,9 +968,7 @@ Curl_ldap_simple_bind_s_a(void * ld, char * dn, char * passwd)
     i = strlen(passwd);
 
     if(!(epasswd = malloc(i + 1))) {
-      if(edn)
-        free(edn);
-
+      free(edn);
       return LDAP_NO_MEMORY;
       }
 
@@ -996,13 +977,8 @@ Curl_ldap_simple_bind_s_a(void * ld, char * dn, char * passwd)
     }
 
   i = ldap_simple_bind_s(ld, edn, epasswd);
-
-  if(epasswd)
-    free(epasswd);
-
-  if(edn)
-    free(edn);
-
+  free(epasswd);
+  free(edn);
   return i;
 }
 
@@ -1079,12 +1055,8 @@ Curl_ldap_search_s_a(void * ld, char * base, int scope, char * filter,
     free(eattrs);
     }
 
-  if(efilter)
-    free(efilter);
-
-  if(ebase)
-    free(ebase);
-
+  free(efilter);
+  free(ebase);
   return status;
 }
 
@@ -1112,9 +1084,7 @@ Curl_ldap_get_values_len_a(void * ld, LDAPMessage * entry, const char * attr)
     }
 
   result = ldap_get_values_len(ld, entry, cp);
-
-  if(cp)
-    free(cp);
+  free(cp);
 
   /* Result data are binary in nature, so they haven't been
      converted to EBCDIC. Therefore do not convert. */
