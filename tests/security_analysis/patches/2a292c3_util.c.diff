@@ -23,7 +23,9 @@
  ***************************************************************************/
 #include "server_setup.h"
 
+#ifndef UNDER_CE
 #include <signal.h>
+#endif
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
@@ -44,6 +46,10 @@
 #include <dos.h>  /* delay() */
 #endif
 
+#ifdef _WIN32
+#include "strerror.h"
+#endif
+
 #include "curlx.h" /* from the private lib dir */
 #include "getpart.h"
 #include "util.h"
@@ -136,22 +142,12 @@ void logmsg(const char *msg, ...)
 }
 
 #ifdef _WIN32
-/* use instead of strerror() on generic Windows */
-static const char *win32_strerror(int err, char *buf, size_t buflen)
-{
-  if(!FormatMessageA((FORMAT_MESSAGE_FROM_SYSTEM |
-                      FORMAT_MESSAGE_IGNORE_INSERTS), NULL, (DWORD)err,
-                     LANG_NEUTRAL, buf, (DWORD)buflen, NULL))
-    msnprintf(buf, buflen, "Unknown error %d (%#x)", err, err);
-  return buf;
-}
-
 /* use instead of perror() on generic Windows */
 void win32_perror(const char *msg)
 {
   char buf[512];
   int err = SOCKERRNO;
-  win32_strerror(err, buf, sizeof(buf));
+  Curl_winapi_strerror(err, buf, sizeof(buf));
   if(msg)
     fprintf(stderr, "%s: ", msg);
   fprintf(stderr, "%s\n", buf);
@@ -193,11 +189,11 @@ void win32_cleanup(void)
   _flushall();
 }
 
-/* socket-safe strerror (works on Winsock errors, too */
+/* socket-safe strerror (works on Winsock errors, too) */
 const char *sstrerror(int err)
 {
   static char buf[512];
-  return win32_strerror(err, buf, sizeof(buf));
+  return Curl_winapi_strerror(err, buf, sizeof(buf));
 }
 #endif  /* _WIN32 */
 
@@ -244,7 +240,7 @@ int wait_ms(int timeout_ms)
   if(!timeout_ms)
     return 0;
   if(timeout_ms < 0) {
-    errno = EINVAL;
+    CURL_SETERRNO(EINVAL);
     return -1;
   }
 #if defined(MSDOS)
@@ -503,12 +499,8 @@ static SIGHANDLER_T old_sigterm_handler = SIG_ERR;
 static SIGHANDLER_T old_sigbreak_handler = SIG_ERR;
 #endif
 
-#if defined(_WIN32) && !defined(CURL_WINDOWS_UWP)
-#ifdef _WIN32_WCE
-static DWORD thread_main_id = 0;
-#else
+#if defined(_WIN32) && !defined(CURL_WINDOWS_UWP) && !defined(UNDER_CE)
 static unsigned int thread_main_id = 0;
-#endif
 static HANDLE thread_main_window = NULL;
 static HWND hidden_main_window = NULL;
 #endif
@@ -529,6 +521,7 @@ HANDLE exit_event = NULL;
  * The first time this is called it will set got_exit_signal to one and
  * store in exit_signal the signal that triggered its execution.
  */
+#ifndef UNDER_CE
 static void exit_signal_handler(int signum)
 {
   int old_errno = errno;
@@ -542,10 +535,11 @@ static void exit_signal_handler(int signum)
 #endif
   }
   (void)signal(signum, exit_signal_handler);
-  errno = old_errno;
+  CURL_SETERRNO(old_errno);
 }
+#endif
 
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(UNDER_CE)
 /* CTRL event handler for Windows Console applications to simulate
  * SIGINT, SIGTERM and SIGBREAK on CTRL events and trigger signal handler.
  *
@@ -593,7 +587,7 @@ static BOOL WINAPI ctrl_event_handler(DWORD dwCtrlType)
 }
 #endif
 
-#if defined(_WIN32) && !defined(CURL_WINDOWS_UWP)
+#if defined(_WIN32) && !defined(CURL_WINDOWS_UWP) && !defined(UNDER_CE)
 /* Window message handler for Windows applications to add support
  * for graceful process termination via taskkill (without /f) which
  * sends WM_CLOSE to all Windows of a process (even hidden ones).
@@ -625,12 +619,8 @@ static LRESULT CALLBACK main_window_proc(HWND hwnd, UINT uMsg,
 }
 /* Window message queue loop for hidden main window, details see above.
  */
-#ifdef _WIN32_WCE
-static DWORD WINAPI main_window_loop(LPVOID lpParameter)
-#else
 #include <process.h>
 static unsigned int WINAPI main_window_loop(void *lpParameter)
-#endif
 {
   WNDCLASS wc;
   BOOL ret;
@@ -678,6 +668,7 @@ static unsigned int WINAPI main_window_loop(void *lpParameter)
 }
 #endif
 
+#ifndef UNDER_CE
 static SIGHANDLER_T set_signal(int signum, SIGHANDLER_T handler,
                                bool restartable)
 {
@@ -707,6 +698,7 @@ static SIGHANDLER_T set_signal(int signum, SIGHANDLER_T handler,
   return oldhdlr;
 #endif
 }
+#endif
 
 void install_signal_handlers(bool keep_sigalrm)
 {
@@ -757,24 +749,17 @@ void install_signal_handlers(bool keep_sigalrm)
     logmsg("cannot install SIGBREAK handler: %s", strerror(errno));
 #endif
 #ifdef _WIN32
+#ifndef UNDER_CE
   if(!SetConsoleCtrlHandler(ctrl_event_handler, TRUE))
     logmsg("cannot install CTRL event handler");
+#endif
 
-#ifndef CURL_WINDOWS_UWP
+#if !defined(CURL_WINDOWS_UWP) && !defined(UNDER_CE)
   {
-#ifdef _WIN32_WCE
-    typedef HANDLE curl_win_thread_handle_t;
-#else
     typedef uintptr_t curl_win_thread_handle_t;
-#endif
     curl_win_thread_handle_t thread;
-#ifdef _WIN32_WCE
-    thread = CreateThread(NULL, 0, &main_window_loop,
-                          (LPVOID)GetModuleHandle(NULL), 0, &thread_main_id);
-#else
     thread = _beginthreadex(NULL, 0, &main_window_loop,
                             (void *)GetModuleHandle(NULL), 0, &thread_main_id);
-#endif
     thread_main_window = (HANDLE)thread;
     if(!thread_main_window || !thread_main_id)
       logmsg("cannot start main window loop");
@@ -814,8 +799,10 @@ void restore_signal_handlers(bool keep_sigalrm)
     (void) set_signal(SIGBREAK, old_sigbreak_handler, FALSE);
 #endif
 #ifdef _WIN32
+#ifndef UNDER_CE
   (void)SetConsoleCtrlHandler(ctrl_event_handler, FALSE);
-#ifndef CURL_WINDOWS_UWP
+#endif
+#if !defined(CURL_WINDOWS_UWP) && !defined(UNDER_CE)
   if(thread_main_window && thread_main_id) {
     if(PostThreadMessage(thread_main_id, WM_APP, 0, 0)) {
       if(WaitForSingleObjectEx(thread_main_window, INFINITE, TRUE)) {
