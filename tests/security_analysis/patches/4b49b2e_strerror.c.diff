@@ -254,14 +254,13 @@ curl_easy_strerror(CURLcode error)
 const char *
 curl_multi_strerror(CURLMcode error)
 {
-  switch (error)
-  {
+  switch (error) {
   case CURLM_CALL_MULTI_PERFORM:
     return "please call curl_multi_perform() soon";
-
+    
   case CURLM_OK:
     return "no error";
-
+    
   case CURLM_BAD_HANDLE:
     return "CURLM not valid multi handle";
 
@@ -284,8 +283,7 @@ curl_multi_strerror(CURLMcode error)
 const char *
 curl_share_strerror(CURLSHcode error)
 {
-  switch (error)
-  {
+  switch (error) {
   case CURLSHE_OK:
     return "no error";
 
@@ -314,173 +312,172 @@ get_winsock_error (int err, char *buf, size_t len)
 {
   char *p;
 
-  switch (err)
-  {
-    case WSAEINTR:
-        p = "Call interrupted.";
-        break;
-    case WSAEBADF:
-        p = "Bad file";
-        break;
-    case WSAEACCES:
-        p = "Bad access";
-        break;
-    case WSAEFAULT:
-        p = "Bad argument";
-        break;
-    case WSAEINVAL:
-        p = "Invalid arguments";
-        break;
-    case WSAEMFILE:
-        p = "Out of file descriptors";
-        break;
-    case WSAEWOULDBLOCK:
-        p = "Call would block";
-        break;
-    case WSAEINPROGRESS:
-    case WSAEALREADY:
-        p = "Blocking call in progress";
-        break;
-    case WSAENOTSOCK:
-        p = "Descriptor is not a socket.";
-        break;
-    case WSAEDESTADDRREQ:
-        p = "Need destination address";
-        break;
-    case WSAEMSGSIZE:
-        p = "Bad message size";
-        break;
-    case WSAEPROTOTYPE:
-        p = "Bad protocol";
-        break;
-    case WSAENOPROTOOPT:
-        p = "Protocol option is unsupported";
-        break;
-    case WSAEPROTONOSUPPORT:
-        p = "Protocol is unsupported";
-        break;
-    case WSAESOCKTNOSUPPORT:
-        p = "Socket is unsupported";
-        break;
-    case WSAEOPNOTSUPP:
-        p = "Operation not supported";
-        break;
-    case WSAEAFNOSUPPORT:
-        p = "Address family not supported";
-        break;
-    case WSAEPFNOSUPPORT:
-        p = "Protocol family not supported";
-        break;
-    case WSAEADDRINUSE:
-        p = "Address already in use";
-        break;
-    case WSAEADDRNOTAVAIL:
-        p = "Address not available";
-        break;
-    case WSAENETDOWN:
-        p = "Network down";
-        break;
-    case WSAENETUNREACH:
-        p = "Network unreachable";
-        break;
-    case WSAENETRESET:
-        p = "Network has been reset";
-        break;
-    case WSAECONNABORTED:
-        p = "Connection was aborted";
-        break;
-    case WSAECONNRESET:
-        p = "Connection was reset";
-        break;
-    case WSAENOBUFS:
-        p = "No buffer space";
-        break;
-    case WSAEISCONN:
-        p = "Socket is already connected";
-        break;
-    case WSAENOTCONN:
-        p = "Socket is not connected";
-        break;
-    case WSAESHUTDOWN:
-        p = "Socket has been shut down";
-        break;
-    case WSAETOOMANYREFS:
-        p = "Too many references";
-        break;
-    case WSAETIMEDOUT:
-        p = "Timed out";
-        break;
-    case WSAECONNREFUSED:
-        p = "Connection refused";
-        break;
-    case WSAELOOP:
-        p = "Loop??";
-        break;
-    case WSAENAMETOOLONG:
-        p = "Name too long";
-        break;
-    case WSAEHOSTDOWN:
-        p = "Host down";
-        break;
-    case WSAEHOSTUNREACH:
-        p = "Host unreachable";
-        break;
-    case WSAENOTEMPTY:
-        p = "Not empty";
-        break;
-    case WSAEPROCLIM:
-        p = "Process limit reached";
-        break;
-    case WSAEUSERS:
-        p = "Too many users";
-        break;
-    case WSAEDQUOT:
-        p = "Bad quota";
-        break;
-    case WSAESTALE:
-        p = "Something is stale";
-        break;
-    case WSAEREMOTE:
-        p = "Remote error";
-        break;
-    case WSAEDISCON:
-        p = "Disconnected";
-        break;
+  switch (err) {
+  case WSAEINTR:
+    p = "Call interrupted.";
+    break;
+  case WSAEBADF:
+    p = "Bad file";
+    break;
+  case WSAEACCES:
+    p = "Bad access";
+    break;
+  case WSAEFAULT:
+    p = "Bad argument";
+    break;
+  case WSAEINVAL:
+    p = "Invalid arguments";
+    break;
+  case WSAEMFILE:
+    p = "Out of file descriptors";
+    break;
+  case WSAEWOULDBLOCK:
+    p = "Call would block";
+    break;
+  case WSAEINPROGRESS:
+  case WSAEALREADY:
+    p = "Blocking call in progress";
+    break;
+  case WSAENOTSOCK:
+    p = "Descriptor is not a socket.";
+    break;
+  case WSAEDESTADDRREQ:
+    p = "Need destination address";
+    break;
+  case WSAEMSGSIZE:
+    p = "Bad message size";
+    break;
+  case WSAEPROTOTYPE:
+    p = "Bad protocol";
+    break;
+  case WSAENOPROTOOPT:
+    p = "Protocol option is unsupported";
+    break;
+  case WSAEPROTONOSUPPORT:
+    p = "Protocol is unsupported";
+    break;
+  case WSAESOCKTNOSUPPORT:
+    p = "Socket is unsupported";
+    break;
+  case WSAEOPNOTSUPP:
+    p = "Operation not supported";
+    break;
+  case WSAEAFNOSUPPORT:
+    p = "Address family not supported";
+    break;
+  case WSAEPFNOSUPPORT:
+    p = "Protocol family not supported";
+    break;
+  case WSAEADDRINUSE:
+    p = "Address already in use";
+    break;
+  case WSAEADDRNOTAVAIL:
+    p = "Address not available";
+    break;
+  case WSAENETDOWN:
+    p = "Network down";
+    break;
+  case WSAENETUNREACH:
+    p = "Network unreachable";
+    break;
+  case WSAENETRESET:
+    p = "Network has been reset";
+    break;
+  case WSAECONNABORTED:
+    p = "Connection was aborted";
+    break;
+  case WSAECONNRESET:
+    p = "Connection was reset";
+    break;
+  case WSAENOBUFS:
+    p = "No buffer space";
+    break;
+  case WSAEISCONN:
+    p = "Socket is already connected";
+    break;
+  case WSAENOTCONN:
+    p = "Socket is not connected";
+    break;
+  case WSAESHUTDOWN:
+    p = "Socket has been shut down";
+    break;
+  case WSAETOOMANYREFS:
+    p = "Too many references";
+    break;
+  case WSAETIMEDOUT:
+    p = "Timed out";
+    break;
+  case WSAECONNREFUSED:
+    p = "Connection refused";
+    break;
+  case WSAELOOP:
+    p = "Loop??";
+    break;
+  case WSAENAMETOOLONG:
+    p = "Name too long";
+    break;
+  case WSAEHOSTDOWN:
+    p = "Host down";
+    break;
+  case WSAEHOSTUNREACH:
+    p = "Host unreachable";
+    break;
+  case WSAENOTEMPTY:
+    p = "Not empty";
+    break;
+  case WSAEPROCLIM:
+    p = "Process limit reached";
+    break;
+  case WSAEUSERS:
+    p = "Too many users";
+    break;
+  case WSAEDQUOT:
+    p = "Bad quota";
+    break;
+  case WSAESTALE:
+    p = "Something is stale";
+    break;
+  case WSAEREMOTE:
+    p = "Remote error";
+    break;
+  case WSAEDISCON:
+    p = "Disconnected";
+    break;
 
     /* Extended Winsock errors */
-    case WSASYSNOTREADY:
-        p = "Winsock library is not ready";
-        break;
-    case WSANOTINITIALISED:
-        p = "Winsock library not initalised";
-        break;
-    case WSAVERNOTSUPPORTED:
-        p = "Winsock version not supported.";
-        break;
+  case WSASYSNOTREADY:
+    p = "Winsock library is not ready";
+    break;
+  case WSANOTINITIALISED:
+    p = "Winsock library not initalised";
+    break;
+  case WSAVERNOTSUPPORTED:
+    p = "Winsock version not supported.";
+    break;
 
     /* getXbyY() errors (already handled in herrmsg):
      * Authoritative Answer: Host not found */
-    case WSAHOST_NOT_FOUND:
-        p = "Host not found";
-        break;
+  case WSAHOST_NOT_FOUND:
+    p = "Host not found";
+    break;
 
     /* Non-Authoritative: Host not found, or SERVERFAIL */
-    case WSATRY_AGAIN:
-        p = "Host not found, try again";
-        break;
+  case WSATRY_AGAIN:
+    p = "Host not found, try again";
+    break;
 
     /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
-    case WSANO_RECOVERY:
-        p = "Unrecoverable error in call to nameserver";
-        break;
+  case WSANO_RECOVERY:
+    p = "Unrecoverable error in call to nameserver";
+    break;
 
     /* Valid name, no data record of requested type */
-    case WSANO_DATA:
-        p = "No data record of requested type";
-        break;
+  case WSANO_DATA:
+    p = "No data record of requested type";
+    break;
 
-    default:
-        return NULL;
+  default:
+    return NULL;
   }
   strncpy (buf, p, len);
   buf [len-1] = '\0';
@@ -524,13 +521,14 @@ const char *Curl_strerror(struct connectdata *conn, int err)
 #endif
     *(buf+max) = '\0';
   }
-  else
+  else {
 #if defined(WIN32) && !defined(__CYGWIN__)
     if (!get_winsock_error (err, buf, max) &&
         !FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM, NULL, err,
                         LANG_NEUTRAL, buf, max, NULL))
 #endif
      snprintf(buf, max, "Unknown error %d (%#x)", err, err);
+  }
 
   /* strip trailing '\r\n' or '\n'. */
   if ((p = strrchr(buf,'\n')) != NULL && (p - buf) >= 2)
